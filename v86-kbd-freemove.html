<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>HTML5 PC Emulator (v86)</title>
	<style>
		:root {
			--bar-h: 34px;
			--bg: #2b2f33;
			--fg: #e6e6e6;
			--hi: #3d8bfd;
			--accent: #4caf50;
			--warn: #ffb74d;
			--led-off: #555a60;
			--led-on: #67d367;
		}
		* { box-sizing: border-box; }
		html, body { height: 100%; margin: 0; background: #101316; color: var(--fg); font: 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; overflow: hidden; }
		#app { height: 100%; display: flex; flex-direction: column; }

		/* XFCE-like top bar */
		.topbar {
			height: var(--bar-h);
			display: flex;
			align-items: center;
			background: linear-gradient(#3a3f44, #2e3338);
			color: var(--fg);
			border-bottom: 1px solid #0009;
			padding: 0 10px;
			user-select: none;
			flex: none;
			z-index: 5;
		}
		.menus { display: flex; gap: 12px; }
		.menu { position: relative; padding: 6px 10px; border-radius: 3px; cursor: default; }
		.menu:hover, .menu.open { background: #ffffff0f; }
		.menu > .title { letter-spacing: .2px; }
		.dropdown { position: absolute; top: calc(100% + 4px); left: 0; min-width: 260px; background: #2e3338; border: 1px solid #000a; box-shadow: 0 6px 20px #000a; border-radius: 6px; padding: 6px 8px; display: none; z-index: 50; }
		.menu.open .dropdown { display: block; }
		.item { padding: 8px 10px; border-radius: 4px; display: flex; align-items: center; justify-content: space-between; gap: 10px; white-space: nowrap; cursor: default; }
		.item:hover { background: #ffffff12; }
		.kbd { padding: 1px 6px; font: 11px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color: #ccd; background: #0008; border-radius: 3px; }
		.sep { height: 1px; background: #000a; margin: 6px 4px; }

		.spacer { flex: 1; }
		.indicators { display: flex; align-items: center; gap: 14px; }
		.led { display: inline-flex; align-items: center; gap: 6px; font-size: 12px; color: #cfd8dc; }
		.dot { width: 10px; height: 10px; border-radius: 50%; background: var(--led-off); box-shadow: inset 0 0 3px #0008; transition: background .08s linear, box-shadow .08s linear; }
		.dot.on { background: var(--led-on); box-shadow: 0 0 6px #67d367; }
		.drvstat { width: 10px; height: 10px; border-radius: 2px; background: #7a7f85; box-shadow: inset 0 0 2px #0009; margin-left: 2px; }
		.drvstat.ready { background: var(--accent); box-shadow: 0 0 5px #4caf50; }

		/* Emulator area (from v86-mobile patterns) */
		#emu-area { flex: 1; display: flex; min-height: 0; min-width: 0; overflow: hidden; align-items: stretch; }
		#screen-container { flex: 1 1 0; display: flex; align-items: stretch; justify-content: center; background: #000; min-width: 0; min-height: 0; position: relative; overflow: hidden; }
		#screen-canvas, #screen-text { position: absolute; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%; }
		#screen-canvas { z-index: 1; display: block; background: #000; image-rendering: pixelated; }
		#screen-text { z-index: 2; pointer-events: none; display: block; opacity: 1; font-family: "Consolas", "Lucida Console", "Courier New", monospace; font-size: 18px; line-height: 1.1; color: #C0C0C0; background: transparent; white-space: pre; letter-spacing: 0.05em; user-select: none; }

		/* Sliders embedded in Options dropdown */
		.slider-row { display: flex; align-items: center; gap: 10px; padding: 6px 4px; }
		.slider-row input[type=range] { width: 160px; }

		/* Hidden file inputs */
		input[type=file] { position: fixed; left: -9999px; top: -9999px; }

		/* Popup keyboard (adapted from v86-mobile) */
		#popup-keyboard { position: absolute; left: 50%; bottom: 10px; transform: translateX(-50%); transform-origin: bottom center; z-index: 20; background: #2e3338; border: 1px solid #000a; border-radius: 10px; box-shadow: 0 2px 20px #0008; padding: 10px; min-width: 820px; max-width: 92vw; user-select: none; display: none; }
		#popup-keyboard .kb-row { display: flex; gap: 8px; margin: 6px 0; }
		#popup-keyboard .kb-key { position: relative; background: #3a3f44; border: 1px solid #555a60; border-radius: 6px; box-shadow: 0 2px 6px #0006; font-size: 26px; color: #e0e0e0; padding: 8px 10px; min-width: 47px; min-height: 41px; cursor: pointer; transition: background .15s, border-color .15s; }
		#popup-keyboard .kb-key:active, #popup-keyboard .kb-key.kb-active { background: #50555b; border-color: #7a7f85; }
		#popup-keyboard .kb-wide { min-width: 66px; }
		#popup-keyboard .kb-shift { min-width: 84px; }
		#popup-keyboard .kb-space { min-width: 200px; }
		#popup-keyboard .kb-ctrl, #popup-keyboard .kb-alt { min-width: 54px; }
		#popup-keyboard .kb-arrow { min-width: 70px; background: #353a3f; }
		#popup-keyboard .kb-key.kb-locked { background: var(--hi); border-color: #7aa7ff; color: #fff; box-shadow: 0 0 0 1px #0006, 0 0 10px #3d8bfd99; }
		#popup-keyboard .kb-led { position: absolute; right: 6px; top: 6px; width: 8px; height: 8px; border-radius: 50%; background: var(--led-off); box-shadow: inset 0 0 2px #0008; }
		#popup-keyboard .kb-led.on { background: var(--led-on); box-shadow: 0 0 6px #67d367; }
		/* Keyboard omni-directional drag handle */
		#kb-drag { display: inline-block; width: 40px; height: 32px; margin-right: 8px; border-radius: 8px; background: linear-gradient(#4a5056, #3a3f44); box-shadow: inset 0 1px 2px #0008; cursor: move; vertical-align: middle; }


		/* Help overlay */
		#help-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 100; display: none; align-items: center; justify-content: center; }
		#help-modal { width: min(860px, 92vw); max-height: 84vh; overflow: auto; background: #2e3338; color: var(--fg); border: 1px solid #000a; border-radius: 10px; box-shadow: 0 12px 32px #000c; padding: 18px 20px; }
		#help-modal h2 { margin: 0 0 8px; font-size: 18px; }
		#help-modal h3 { margin: 16px 0 6px; font-size: 14px; color: #d7dee4; }
		#help-modal p, #help-modal li { font-size: 13px; color: #d0d6db; }
		#help-close { float: right; margin-left: 10px; }
	</style>
	<script src="./libv86.js"></script>
</head>
<body>
	<div id="app">
		<div class="topbar" id="topbar">
			<div class="menus">
				<div class="menu" data-menu="file">
					<div class="title">File</div>
					<div class="dropdown">
						<div class="item" id="mi-fd-load">Load Floppy (A:)… <span class="kbd">.img/.ima</span></div>
						<div class="item" id="mi-hd-load">Load Hard Disk… <span class="kbd">.img</span></div>
						<div class="item" id="mi-cd-load">Load CD-ROM… <span class="kbd">.iso/.img</span></div>
						<div class="sep"></div>
						<div class="item" id="mi-boot-now">Boot <span class="kbd">Ctrl+B</span></div>
						<div class="item" id="mi-reset">Reset</div>
						<div class="sep"></div>
						<div class="item" id="mi-eject-fd">Eject Floppy</div>
						<div class="item" id="mi-eject-cd">Eject CD-ROM</div>
						<div class="sep"></div>
						<div class="item" id="mi-help">Help</div>
					</div>
				</div>

				<div class="menu" data-menu="options">
					<div class="title">Options</div>
					<div class="dropdown">
						<div class="item" style="flex-direction: column; align-items: flex-start; gap: 6px;">
							<div class="slider-row">
								<span>RAM:</span>
								<input type="range" id="ram-slider" min="2" max="128" step="1" value="64">
								<span id="ram-value" class="kbd">64 MB</span>
							</div>
							<div class="slider-row">
								<span>VGA:</span>
								<input type="range" id="vga-slider" min="64" max="4096" step="1" value="2048">
								<span id="vga-value" class="kbd">2048 KB</span>
							</div>
							<div class="slider-row">
								<span>KBD:</span>
								<input type="range" id="kbsize-slider" min="25" max="100" step="5" value="45">
								<span id="kbsize-value" class="kbd">45%</span>
							</div>
							<div class="sep" style="width:100%"></div>
							<div class="slider-row" title="Larger slice reduces yield overhead; increases UI latency slightly">
								<span>Time slice:</span>
								<input type="range" id="slice-slider" min="1" max="20" step="1" value="4">
								<span id="slice-value" class="kbd">4 ms</span>
							</div>
							<div class="slider-row" title="JIT cache page span (higher compiles larger cross-page blocks)">
								<span>JIT pages:</span>
								<input type="range" id="jitpages-slider" min="1" max="8" step="1" value="5">
								<span id="jitpages-value" class="kbd">5</span>
							</div>
							<div class="slider-row" title="Dispatcher fanout budget (higher groups more basic blocks)">
								<span>JIT fanout:</span>
								<input type="range" id="jitfanout-slider" min="50" max="1024" step="10" value="512">
								<span id="jitfanout-value" class="kbd">512</span>
							</div>
							<div class="item" style="gap:10px;">
								<label style="display:flex;align-items:center;gap:8px;">
									<input type="checkbox" id="loop-safety" checked>
									<span>Loop safety</span>
								</label>
								<label style="display:flex;align-items:center;gap:8px;">
									<input type="checkbox" id="throughput-profile">
									<span>Throughput profile</span>
								</label>
							</div>
							<div class="item" id="mi-apply-memory" style="width: 100%; justify-content: center;">Apply (re-init)</div>
						</div>
						<div class="sep"></div>
						<div class="item" id="mi-mouse-capture">Mouse: Capture</div>
						<div class="sep"></div>
						<div class="item" id="mi-keyboard">Keyboard: Show</div>
						<div class="sep"></div>
						<div class="item" id="mi-fullscreen">Toggle Fullscreen</div>
					</div>
				</div>

				<div class="menu" data-menu="boot">
					<div class="title">Boot</div>
					<div class="dropdown">
						<div class="item" data-boot="fd,hd,cd">Boot order: FD, HD, CD</div>
						<div class="item" data-boot="hd,fd,cd">Boot order: HD, FD, CD</div>
						<div class="item" data-boot="cd,hd,fd">Boot order: CD, HD, FD</div>
					</div>
				</div>
			</div>

			<div class="spacer"></div>
			<div class="indicators">
				<div class="led" title="Floppy activity">
					<div class="dot" id="led-fd"></div>
					FD
					<div class="drvstat" id="stat-fd" title="Floppy image loaded"></div>
				</div>
				<div class="led" title="Hard disk activity">
					<div class="dot" id="led-hd"></div>
					HD
					<div class="drvstat" id="stat-hd" title="Hard disk image loaded"></div>
				</div>
				<div class="led" title="CD-ROM activity">
					<div class="dot" id="led-cd"></div>
					CD
					<div class="drvstat" id="stat-cd" title="CD image loaded"></div>
				</div>
			</div>
		</div>

		<div id="emu-area">
			<div id="screen-container">
				<canvas id="screen-canvas" tabindex="1" style="outline:none;"></canvas>
				<div id="screen-text"></div>
				<!-- Help overlay -->
				<div id="help-overlay">
					<div id="help-modal">
						<button id="help-close" class="kb-key" style="min-width:36px; min-height:32px;">✕</button>
						<h2>Help</h2>
						<p>Quick tips for using the emulator.</p>
						<h3>Mouse</h3>
						<ul>
							<li>Capture: Options → Mouse: Capture (or click screen in some browsers).</li>
							<li>Release: Press Ctrl+Alt together, or click the middle mouse button.</li>
						</ul>
						<h3>Media</h3>
						<ul>
							<li>Load images from File → Load Floppy/Hard Disk/CD-ROM. Eject from File.</li>
							<li>LEDs: FD/HD/CD light on activity. DrvStat squares turn green when media is loaded.</li>
						</ul>
						<h3>Keyboard</h3>
						<ul>
							<li>Toggle on-screen keyboard from Options → Keyboard.</li>
							<li>Resize via Options → KBD.</li>
							<li>Move KBD: drag the small handle next to the ✕ button.</li>
							<li>Hold Shift/Alt/Ctrl for ~1s to lock; click again to unlock.</li>
							<li>Hold Caps for ~1s to lock; its small LED on the key shows lock state. Click again to unlock.</li>
						</ul>
						<h3>Boot</h3>
						<ul>
							<li>Choose boot order from the Boot menu. Use File → Boot to start after changing settings.</li>
						</ul>
					</div>
				</div>
				<!-- Popup keyboard -->
				<div id="popup-keyboard">
					<div style="display:flex; align-items:center; justify-content:flex-end; gap:8px; margin-bottom:6px;">
						<div id="kb-drag" title="Drag to move keyboard"></div>
						<button id="close-keyboard-btn" class="kb-key" style="min-width:44px; min-height:40px;">✕</button>
					</div>
					<div id="keyboard-rows">
						<div class="kb-row">
							<button class="kb-key" data-key="Escape">Esc</button>
							<span style="width:12px;display:inline-block;"></span>
							<button class="kb-key" data-key="F1">F1</button>
							<button class="kb-key" data-key="F2">F2</button>
							<button class="kb-key" data-key="F3">F3</button>
							<button class="kb-key" data-key="F4">F4</button>
							<span style="width:12px;display:inline-block;"></span>
							<button class="kb-key" data-key="F5">F5</button>
							<button class="kb-key" data-key="F6">F6</button>
							<button class="kb-key" data-key="F7">F7</button>
							<button class="kb-key" data-key="F8">F8</button>
							<span style="width:12px;display:inline-block;"></span>
							<button class="kb-key" data-key="F9">F9</button>
							<button class="kb-key" data-key="F10">F10</button>
							<button class="kb-key" data-key="F11">F11</button>
							<button class="kb-key" data-key="F12">F12</button>
						</div>
						<div class="kb-row">
							<button class="kb-key" data-key="Backquote">`</button>
							<button class="kb-key" data-key="Digit1">1</button>
							<button class="kb-key" data-key="Digit2">2</button>
							<button class="kb-key" data-key="Digit3">3</button>
							<button class="kb-key" data-key="Digit4">4</button>
							<button class="kb-key" data-key="Digit5">5</button>
							<button class="kb-key" data-key="Digit6">6</button>
							<button class="kb-key" data-key="Digit7">7</button>
							<button class="kb-key" data-key="Digit8">8</button>
							<button class="kb-key" data-key="Digit9">9</button>
							<button class="kb-key" data-key="Digit0">0</button>
							<button class="kb-key" data-key="Minus">-</button>
							<button class="kb-key" data-key="Equal">=</button>
							<button class="kb-key kb-wide" data-key="Bckspc">Bcks</button>
						</div>
						<div class="kb-row">
							<button class="kb-key kb-wide" data-key="Tab">Tab</button>
							<button class="kb-key" data-key="KeyQ">Q</button>
							<button class="kb-key" data-key="KeyW">W</button>
							<button class="kb-key" data-key="KeyE">E</button>
							<button class="kb-key" data-key="KeyR">R</button>
							<button class="kb-key" data-key="KeyT">T</button>
							<button class="kb-key" data-key="KeyY">Y</button>
							<button class="kb-key" data-key="KeyU">U</button>
							<button class="kb-key" data-key="KeyI">I</button>
							<button class="kb-key" data-key="KeyO">O</button>
							<button class="kb-key" data-key="KeyP">P</button>
							<button class="kb-key" data-key="BracketLeft">[</button>
							<button class="kb-key" data-key="BracketRight">]</button>
							<button class="kb-key" data-key="Backslash">\\</button>
						</div>
						<div class="kb-row">
							<button class="kb-key kb-wide" data-key="CapsLock">Caps<span class="kb-led" id="caps-led"></span></button>
							<button class="kb-key" data-key="KeyA">A</button>
							<button class="kb-key" data-key="KeyS">S</button>
							<button class="kb-key" data-key="KeyD">D</button>
							<button class="kb-key" data-key="KeyF">F</button>
							<button class="kb-key" data-key="KeyG">G</button>
							<button class="kb-key" data-key="KeyH">H</button>
							<button class="kb-key" data-key="KeyJ">J</button>
							<button class="kb-key" data-key="KeyK">K</button>
							<button class="kb-key" data-key="KeyL">L</button>
							<button class="kb-key" data-key="Colon">:</button>
							<button class="kb-key" data-key="Quote">'</button>
							<button class="kb-key kb-wide" data-key="Enter">Enter</button>
						</div>
						<div class="kb-row">
							<button class="kb-key kb-wide kb-shift" data-key="ShiftLeft">Shift</button>
							<button class="kb-key" data-key="KeyZ">Z</button>
							<button class="kb-key" data-key="KeyX">X</button>
							<button class="kb-key" data-key="KeyC">C</button>
							<button class="kb-key" data-key="KeyV">V</button>
							<button class="kb-key" data-key="KeyB">B</button>
							<button class="kb-key" data-key="KeyN">N</button>
							<button class="kb-key" data-key="KeyM">M</button>
							<button class="kb-key" data-key="Comma">,</button>
							<button class="kb-key" data-key="Period">.</button>
							<button class="kb-key" data-key="Slash">/</button>
							<button class="kb-key kb-wide kb-shift" data-key="ShiftRight">Shift</button>
						</div>
						<div class="kb-row" style="align-items:flex-end;">
							<button class="kb-key kb-ctrl" data-key="ControlLeft">Ctrl</button>
							<button class="kb-key kb-alt" data-key="AltLeft">Alt</button>
							<button class="kb-key kb-space" data-key="Space">Space</button>
							<button class="kb-key kb-alt" data-key="AltRight">Alt</button>
							<button class="kb-key kb-ctrl" data-key="ControlRight">Ctrl</button>
							<span style="width:100px;display:inline-block;"></span>
							<div style="display:inline-flex; flex-direction:column; align-items:center;">
								<button class="kb-key kb-arrow" data-key="ArrowUp" style="margin-bottom:10px;">↑</button>
								<div style="display:flex; gap:10px;">
									<button class="kb-key kb-arrow" data-key="ArrowLeft">←</button>
									<button class="kb-key kb-arrow" data-key="ArrowDown">↓</button>
									<button class="kb-key kb-arrow" data-key="ArrowRight">→</button>
								</div>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>

	<!-- Hidden file inputs -->
	<input type="file" id="file-fd" accept=".img,.ima,.bin,.fd,.dsk,.vfd,.flp,.img.gz,.ima.gz,.bin.gz" />
	<input type="file" id="file-hd" accept=".img,.vhd,.qcow,.qcow2,.raw,.img.gz,.vhd.gz" />
	<input type="file" id="file-cd" accept=".iso,.cue,.bin,.img,.iso.gz,.bin.gz" />

	<script>
		// Adopt working patterns from v86-mobile.html
		let emulator = null;
		let lastFloppy = null;
		let lastHdd = null;
		let lastCd = null;
		let bootOrder = 801; // FD,HD,CD
		const USE_GRAPHICAL_TEXT = true; // Render text mode on canvas for consistent scaling
		let fdLedTimer = null; // poller for floppy motor
		let fdLastBlink = 0;   // timestamp for last blink
		// Flag to track if the keyboard has been moved by the user.
		// This changes how scaling is applied (from center vs. from top-left).
		let kbManuallyPositioned = false;

		// Allowed sizes (from mobile)
		const allowedRam = [2, 4, 8, 16, 32, 64, 128];
		const allowedVga = [64, 128, 256, 512, 1024, 2048, 4096];
		function getClosestAllowed(val, allowed) {
			let closest = allowed[0];
			for (let i = 0; i < allowed.length; ++i) {
				if (Math.abs(val - allowed[i]) < Math.abs(val - closest)) closest = allowed[i];
			}
			return closest;
		}
		function getRamSizeBytes() {
			const slider = document.getElementById('ram-slider');
			const mb = getClosestAllowed(parseInt(slider.value, 10) || 64, allowedRam);
			return mb * 1024 * 1024;
		}
		function getVgaSizeBytes() {
			const slider = document.getElementById('vga-slider');
			const kb = getClosestAllowed(parseInt(slider.value, 10) || 2048, allowedVga);
			return kb * 1024; // v86 expects bytes; VGA in KB
		}
		function updateRamLabel() {
			const val = getClosestAllowed(parseInt(document.getElementById('ram-slider').value, 10) || 64, allowedRam);
			document.getElementById('ram-value').textContent = val + ' MB';
			document.getElementById('ram-slider').value = val;
		}
		function updateVgaLabel() {
			const val = getClosestAllowed(parseInt(document.getElementById('vga-slider').value, 10) || 2048, allowedVga);
			document.getElementById('vga-value').textContent = val + ' KB';
			document.getElementById('vga-slider').value = val;
		}
		function updateKbSize() {
			const slider = document.getElementById('kbsize-slider');
			if (!slider) return;
			const pct = parseInt(slider.value, 10) || 100;
			document.getElementById('kbsize-value').textContent = pct + '%';
			const popup = document.getElementById('popup-keyboard');
			const scale = pct / 100;
			if (popup) {
				if (kbManuallyPositioned) {
					// If user has dragged it, only apply scale and keep top-left origin
					popup.style.transform = `scale(${scale})`;
					popup.style.transformOrigin = 'top left';
				} else {
					// Default centered position
					popup.style.transform = `translateX(-50%) scale(${scale})`;
					popup.style.transformOrigin = 'bottom center';
				}
			}
		}

		function updateSliceLabel(){
			const v = parseInt(document.getElementById('slice-slider').value, 10) || 4;
			document.getElementById('slice-value').textContent = v + ' ms';
		}
		function updateJitPagesLabel(){
			const v = parseInt(document.getElementById('jitpages-slider').value, 10) || 5;
			document.getElementById('jitpages-value').textContent = String(v);
		}
		function updateJitFanoutLabel(){
			const v = parseInt(document.getElementById('jitfanout-slider').value, 10) || 512;
			document.getElementById('jitfanout-value').textContent = String(v);
		}

		function setDrvReady(id, ready) {
			const el = document.getElementById(id);
			el.classList.toggle('ready', !!ready);
		}
		function lightLed(id, duration = 200) {
			const el = document.getElementById(id);
			if (!el) return;
			el.classList.add('on');
			setTimeout(() => el.classList.remove('on'), duration);
		}

		function setVgaScaleToFit() {
			const container = document.getElementById('screen-container');
			const canvas = document.getElementById('screen-canvas');
			const textDiv = document.getElementById('screen-text');
			const rect = container.getBoundingClientRect();
			const availWidth = rect.width;
			const availHeight = rect.height;

			let vgaWidth = 640, vgaHeight = 480;
			if (window.emulator && emulator.screen_adapter) {
				if (emulator.screen_adapter.screen_width && emulator.screen_adapter.screen_height) {
					vgaWidth = emulator.screen_adapter.screen_width;
					vgaHeight = emulator.screen_adapter.screen_height;
				} else if (emulator.screen_adapter.max_cols && emulator.screen_adapter.max_rows) {
					vgaWidth = emulator.screen_adapter.max_cols * 9;
					vgaHeight = emulator.screen_adapter.max_rows * 16;
				}
			}
			let scale = Math.min(availWidth / vgaWidth, availHeight / vgaHeight);
			canvas.style.width = (vgaWidth * scale) + 'px';
			canvas.style.height = (vgaHeight * scale) + 'px';
			canvas.style.left = '0px';
			canvas.style.top = '0px';
			textDiv.style.width = canvas.style.width;
			textDiv.style.height = canvas.style.height;
			textDiv.style.left = canvas.style.left;
			textDiv.style.top = canvas.style.top;
			textDiv.style.fontSize = (18 * scale) + 'px';
		}

		function readPerfOptions(){
			const slice = parseInt(document.getElementById('slice-slider').value, 10) || 4;
			const jitPages = parseInt(document.getElementById('jitpages-slider').value, 10) || 5;
			const jitFanout = parseInt(document.getElementById('jitfanout-slider').value, 10) || 512;
			const loopSafe = !!document.getElementById('loop-safety').checked;
			const throughput = !!document.getElementById('throughput-profile').checked;
			return { slice, jitPages, jitFanout, loopSafe, throughput };
		}

		// Apply performance knobs at runtime when possible
		function applyRuntimePerf(perf){
			if(!emulator) return;
			try {
				// Prefer new convenience methods if available
				if(typeof emulator.set_time_per_frame === 'function'){
					emulator.set_time_per_frame(perf.slice);
				} else if (emulator.v86 && emulator.v86.cpu && typeof emulator.v86.cpu.set_time_per_frame === 'function'){
					emulator.v86.cpu.set_time_per_frame(perf.slice);
				}

				if(typeof emulator.set_jit_options === 'function'){
					emulator.set_jit_options({
						jit_max_pages: perf.jitPages,
						jit_loop_safety: perf.loopSafe,
						jit_max_extra_basic_blocks: perf.jitFanout,
					});
				} else if (emulator.v86 && emulator.v86.cpu && typeof emulator.v86.cpu.set_jit_config === 'function'){
					// Index mapping mirrors CPU.init(): 1=pages, 2=loop_safety, 3=fanout
					emulator.v86.cpu.set_jit_config(1, perf.jitPages >>> 0);
					emulator.v86.cpu.set_jit_config(2, perf.loopSafe ? 1 : 0);
					emulator.v86.cpu.set_jit_config(3, perf.jitFanout >>> 0);
				}

				// Optional: convenience preset
				if(typeof emulator.set_performance_profile === 'function'){
					emulator.set_performance_profile(perf.throughput ? 'throughput' : 'balanced');
				}
			} catch {}
		}

		function createEmulator() {
			if (emulator && typeof emulator.destroy === 'function') {
				// stop any existing FD LED poller
				if (fdLedTimer) { clearInterval(fdLedTimer); fdLedTimer = null; }
				try { emulator.destroy(); } catch {}
			}
			const perf = readPerfOptions();
			emulator = new V86({
				wasm_path: './v86.wasm',
				bios: { url: './bios/seabios.bin' },
				vga_bios: { url: './bios/vgabios.bin' },
				memory_size: getRamSizeBytes(),
				vga_memory_size: getVgaSizeBytes(),
				boot_order: bootOrder,
				screen_container: document.getElementById('screen-container'),
				screen: { use_graphical_text: USE_GRAPHICAL_TEXT },
				fda: lastFloppy ? { buffer: lastFloppy } : undefined,
				hda: lastHdd ? { buffer: lastHdd } : undefined,
				cdrom: lastCd ? { buffer: lastCd } : undefined,
				autostart: false,
				// performance knobs
				time_per_frame_ms: perf.slice,
				jit_max_pages: perf.jitPages,
				jit_max_extra_basic_blocks: perf.jitFanout,
				jit_loop_safety: perf.loopSafe,
				performance: perf.throughput ? 'throughput' : undefined
			});
			window.emulator = emulator;
			// Start with mouse disabled until explicitly captured
			try { emulator.mouse_set_enabled(false); } catch {}

			// Start/refresh FD LED poller
			if (fdLedTimer) { clearInterval(fdLedTimer); fdLedTimer = null; }
			fdLastBlink = 0;
			fdLedTimer = setInterval(() => {
				try {
					const fdc = emulator && emulator.v86 && emulator.v86.cpu && emulator.v86.cpu.devices && emulator.v86.cpu.devices.fdc;
					if (!fdc) return;
					// DOR bit 4 = motor enable drive A:
					const motorOn = !!(fdc.dor & 0x10);
					const now = Date.now();
					if (motorOn) {
						// Blink every 0.5s while motor is on
						if (now - fdLastBlink > 300) {
							fdLastBlink = now;
							lightLed('led-fd', 140);
						}
					}
				} catch {}
			}, 60);

			// Listeners from mobile
			if (emulator.add_listener) {
				emulator.add_listener('screen-set-mode', function(is_graphics) {
					const canvas = document.getElementById('screen-canvas');
					const textDiv = document.getElementById('screen-text');
					if (USE_GRAPHICAL_TEXT) {
						// Always render via canvas; hide DOM text overlay
						canvas.style.display = 'block';
						textDiv.style.opacity = '0';
					} else {
						if (is_graphics) { canvas.style.display = 'block'; textDiv.style.opacity = '0'; }
						else { canvas.style.display = 'block'; textDiv.style.opacity = '1'; }
					}
					setTimeout(setVgaScaleToFit, 0);
				});
				emulator.add_listener('screen-set-size', function() { setTimeout(setVgaScaleToFit, 0); });

				// IDE events: end events carry channel info; channel 1 is CD (secondary), others are HD
				emulator.add_listener('ide-read-end', function(args) {
					try {
						const ch = Array.isArray(args) ? args[0] : (args && args.channel) ? args.channel : 0;
						if (ch === 1) lightLed('led-cd'); else lightLed('led-hd');
					} catch { lightLed('led-hd'); }
				});
				emulator.add_listener('ide-write-end', function() { lightLed('led-hd'); });
				emulator.add_listener('fda-read-start', function() { lightLed('led-fd'); });
				emulator.add_listener('fda-write-start', function() { lightLed('led-fd'); });
			}

			setTimeout(setVgaScaleToFit, 0);
		}

		function setupMenus() {
			const bar = document.getElementById('topbar');
			const menus = Array.from(bar.querySelectorAll('.menu'));
			menus.forEach(m => {
				m.addEventListener('mouseenter', () => {
					if (menus.some(x => x.classList.contains('open'))) m.classList.add('open');
				});
				m.addEventListener('click', (e) => {
					const isOpen = m.classList.contains('open');
					menus.forEach(x => x.classList.remove('open'));
					if (!isOpen) m.classList.add('open');
					e.stopPropagation();
				});
			});
				// Only close menus when clicking outside topbar
				document.addEventListener('click', (ev) => { if (!bar.contains(ev.target)) menus.forEach(x => x.classList.remove('open')); });
				// Prevent dropdown interactions (sliders, etc.) from bubbling and closing the menu
				bar.querySelectorAll('.dropdown').forEach(dd => {
					dd.addEventListener('click', (e) => e.stopPropagation());
					dd.addEventListener('mousedown', (e) => e.stopPropagation());
				});
				// Keyboard size slider events (keep menu open)
				const kbSlider = document.getElementById('kbsize-slider');
				if (kbSlider) {
					['input','change','mousedown','mousemove','touchstart','touchmove'].forEach(ev => {
						kbSlider.addEventListener(ev, (e) => { e.stopPropagation(); updateKbSize(); });
					});
				}

			// File actions
			document.getElementById('mi-fd-load').onclick = () => document.getElementById('file-fd').click();
			document.getElementById('mi-hd-load').onclick = () => document.getElementById('file-hd').click();
			document.getElementById('mi-cd-load').onclick = () => document.getElementById('file-cd').click();
			document.getElementById('mi-boot-now').onclick = () => { try { emulator && emulator.run && emulator.run(); } catch {} };
			document.getElementById('mi-reset').onclick = () => { createEmulator(); };
			document.getElementById('mi-eject-fd').onclick = () => { try { emulator && emulator.eject_fda && emulator.eject_fda(); lastFloppy = null; setDrvReady('stat-fd', false); } catch {} };
			document.getElementById('mi-eject-cd').onclick = () => { try { emulator && emulator.eject_cdrom && emulator.eject_cdrom(); lastCd = null; setDrvReady('stat-cd', false); } catch {} };

			// Options
			document.getElementById('mi-fullscreen').onclick = () => {
				const el = document.getElementById('screen-container');
				if (el.requestFullscreen) el.requestFullscreen();
				else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
				else if (el.mozRequestFullScreen) el.mozRequestFullScreen();
				else if (el.msRequestFullscreen) el.msRequestFullscreen();
			};
			document.getElementById('mi-apply-memory').onclick = () => { updateRamLabel(); updateVgaLabel(); updateSliceLabel(); updateJitPagesLabel(); updateJitFanoutLabel(); createEmulator(); };
			['slice-slider','jitpages-slider','jitfanout-slider'].forEach(id => {
				const el = document.getElementById(id); if (!el) return;
				el.addEventListener('input', () => {
					if (id==='slice-slider') updateSliceLabel();
					if (id==='jitpages-slider') updateJitPagesLabel();
					if (id==='jitfanout-slider') updateJitFanoutLabel();
					// Apply immediately without reboot
					applyRuntimePerf(readPerfOptions());
				});
			});

			// Loop safety toggle applies immediately
			const loopSafety = document.getElementById('loop-safety');
			if(loopSafety){
				loopSafety.addEventListener('change', () => applyRuntimePerf(readPerfOptions()));
			}

			// Throughput profile checkbox: snap sliders to recommended values and apply
			const thpt = document.getElementById('throughput-profile');
			if(thpt){
				thpt.addEventListener('change', () => {
					const checked = !!thpt.checked;
					const pages = checked ? 5 : 3;
					const fanout = checked ? 512 : 250;
					document.getElementById('jitpages-slider').value = String(pages);
					document.getElementById('jitfanout-slider').value = String(fanout);
					updateJitPagesLabel();
					updateJitFanoutLabel();
					applyRuntimePerf(readPerfOptions());
				});
			}
			// Mouse capture toggle
			const mouseItem = document.getElementById('mi-mouse-capture');
			function setMouseItemLabel(captured){ mouseItem.textContent = captured ? 'Mouse: Release' : 'Mouse: Capture'; }
			setMouseItemLabel(false);
			mouseItem.onclick = () => { if (!mouseCaptured) requestMouseCapture(); else releaseMouseCapture(); };

			// Keyboard popup toggle
			const kbItem = document.getElementById('mi-keyboard');
			const popupKb = document.getElementById('popup-keyboard');
			function setKbItemLabel(vis){ kbItem.textContent = vis ? 'Keyboard: Hide' : 'Keyboard: Show'; }
			setKbItemLabel(false);
			kbItem.onclick = () => {
				const visible = popupKb.style.display !== 'none';
				popupKb.style.display = visible ? 'none' : 'block';
				setKbItemLabel(!visible);
			};

			// Boot order
			bar.querySelectorAll('[data-boot]').forEach(el => {
				el.addEventListener('click', () => {
					const kind = el.getAttribute('data-boot');
					const map = { 'fd,hd,cd': 801, 'hd,fd,cd': 786, 'cd,hd,fd': 291 };
					bootOrder = map[kind] || 801;
					createEmulator();
				});
			});

			// Shortcuts
			window.addEventListener('keydown', (e) => {
				if ((e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey) {
					if (e.key === 'b' || e.key === 'B') { e.preventDefault(); try { emulator && emulator.run && emulator.run(); } catch {} }
				}
						// Release mouse: Ctrl+Alt
						if (mouseCaptured && e.ctrlKey && e.altKey) {
							e.preventDefault();
							releaseMouseCapture();
						}
			});
					// Release on middle mouse
					window.addEventListener('mousedown', (e) => {
						if (mouseCaptured && e.button === 1) { e.preventDefault(); releaseMouseCapture(); }
					}, true);

			// Help menu
			const helpItem = document.getElementById('mi-help');
			if (helpItem) helpItem.onclick = () => { showHelp(); };
		}

				// Mouse capture using Pointer Lock
				let mouseCaptured = false;
				function isLockedTo(el){ return document.pointerLockElement === el || document.pointerLockElement === document.getElementById('screen-canvas'); }
				function requestMouseCapture(){
					const el = document.getElementById('screen-container');
					if (!el) return;
					const req = el.requestPointerLock || el.webkitRequestPointerLock || el.mozRequestPointerLock;
					try { el.requestPointerLock({ unadjustedMovement: true }); }
					catch { req && req.call(el); }
				}
				function releaseMouseCapture(){
					if (document.exitPointerLock) document.exitPointerLock();
					else if (document.webkitExitPointerLock) document.webkitExitPointerLock();
					else if (document.mozExitPointerLock) document.mozExitPointerLock();
				}
				function onPointerLockChange(){
					const el = document.getElementById('screen-container');
					const captured = !!el && isLockedTo(el);
					mouseCaptured = captured;
					try { emulator && emulator.mouse_set_enabled && emulator.mouse_set_enabled(captured); } catch {}
					const mouseItem = document.getElementById('mi-mouse-capture');
					if (mouseItem) mouseItem.textContent = captured ? 'Mouse: Release' : 'Mouse: Capture';
				}
				document.addEventListener('pointerlockchange', onPointerLockChange);
				document.addEventListener('mozpointerlockchange', onPointerLockChange);
				document.addEventListener('webkitpointerlockchange', onPointerLockChange);

			// Help modal logic
			function showHelp(){
				const ov = document.getElementById('help-overlay');
				if (ov) ov.style.display = 'block';
			}
			function hideHelp(){
				const ov = document.getElementById('help-overlay');
				if (ov) ov.style.display = 'none';
			}
			window.addEventListener('load', () => {
				const closeBtn = document.getElementById('help-close');
				if (closeBtn) closeBtn.onclick = () => hideHelp();
				const ov = document.getElementById('help-overlay');
				if (ov) ov.addEventListener('click', (e) => { if (e.target === ov) hideHelp(); });
			});

		function wireFileInputs() {
			document.getElementById('file-fd').onchange = (e) => {
				const file = e.target.files[0]; if (!file) return;
				const reader = new FileReader();
				reader.onload = (evt) => {
					lastFloppy = evt.target.result;
					if (emulator && emulator.set_fda) emulator.set_fda({ buffer: lastFloppy });
					setDrvReady('stat-fd', true);
				};
				reader.readAsArrayBuffer(file);
			};
			document.getElementById('file-hd').onchange = (e) => {
				const file = e.target.files[0]; if (!file) return;
				const reader = new FileReader();
				reader.onload = (evt) => {
					lastHdd = evt.target.result;
					setDrvReady('stat-hd', true);
					// Recreate emulator to attach HDA at boot like mobile does
					createEmulator();
				};
				reader.readAsArrayBuffer(file);
			};
			document.getElementById('file-cd').onchange = (e) => {
				const file = e.target.files[0]; if (!file) return;
				const reader = new FileReader();
				reader.onload = (evt) => {
					lastCd = evt.target.result;
					if (emulator && emulator.set_cdrom) emulator.set_cdrom({ buffer: lastCd });
					setDrvReady('stat-cd', true);
				};
				reader.readAsArrayBuffer(file);
			};
		}

		window.addEventListener('load', () => {
			setupMenus();
			setupPopupKeyboard();
			updateRamLabel();
			updateVgaLabel();
			updateKbSize(); updateSliceLabel(); updateJitPagesLabel(); updateJitFanoutLabel();
			wireFileInputs();
			createEmulator();
			window.addEventListener('resize', setVgaScaleToFit);
		});

		// --- On-screen keyboard logic (adapted) ---
		const keyMap = {
			'Escape': { code: 'Escape', keyCode: 27 },
			'F1': { code: 'F1', keyCode: 112 }, 'F2': { code: 'F2', keyCode: 113 }, 'F3': { code: 'F3', keyCode: 114 }, 'F4': { code: 'F4', keyCode: 115 },
			'F5': { code: 'F5', keyCode: 116 }, 'F6': { code: 'F6', keyCode: 117 }, 'F7': { code: 'F7', keyCode: 118 }, 'F8': { code: 'F8', keyCode: 119 },
			'F9': { code: 'F9', keyCode: 120 }, 'F10': { code: 'F10', keyCode: 121 }, 'F11': { code: 'F11', keyCode: 122 }, 'F12': { code: 'F12', keyCode: 123 },
			'Backquote': { code: 'Backquote', keyCode: 192 }, 'Digit1': { code: 'Digit1', keyCode: 49 }, 'Digit2': { code: 'Digit2', keyCode: 50 }, 'Digit3': { code: 'Digit3', keyCode: 51 }, 'Digit4': { code: 'Digit4', keyCode: 52 }, 'Digit5': { code: 'Digit5', keyCode: 53 }, 'Digit6': { code: 'Digit6', keyCode: 54 }, 'Digit7': { code: 'Digit7', keyCode: 55 }, 'Digit8': { code: 'Digit8', keyCode: 56 }, 'Digit9': { code: 'Digit9', keyCode: 57 }, 'Digit0': { code: 'Digit0', keyCode: 48 }, 'Minus': { code: 'Minus', keyCode: 189 }, 'Equal': { code: 'Equal', keyCode: 187 }, 'Bckspc': { code: 'Backspace', keyCode: 8 },
			'Tab': { code: 'Tab', keyCode: 9 }, 'KeyQ': { code: 'KeyQ', keyCode: 81 }, 'KeyW': { code: 'KeyW', keyCode: 87 }, 'KeyE': { code: 'KeyE', keyCode: 69 }, 'KeyR': { code: 'KeyR', keyCode: 82 }, 'KeyT': { code: 'KeyT', keyCode: 84 }, 'KeyY': { code: 'KeyY', keyCode: 89 }, 'KeyU': { code: 'KeyU', keyCode: 85 }, 'KeyI': { code: 'KeyI', keyCode: 73 }, 'KeyO': { code: 'KeyO', keyCode: 79 }, 'KeyP': { code: 'KeyP', keyCode: 80 }, 'BracketLeft': { code: 'BracketLeft', keyCode: 219 }, 'BracketRight': { code: 'BracketRight', keyCode: 221 }, 'Backslash': { code: 'Backslash', keyCode: 220 },
			'CapsLock': { code: 'CapsLock', keyCode: 20 }, 'KeyA': { code: 'KeyA', keyCode: 65 }, 'KeyS': { code: 'KeyS', keyCode: 83 }, 'KeyD': { code: 'KeyD', keyCode: 68 }, 'KeyF': { code: 'KeyF', keyCode: 70 }, 'KeyG': { code: 'KeyG', keyCode: 71 }, 'KeyH': { code: 'KeyH', keyCode: 72 }, 'KeyJ': { code: 'KeyJ', keyCode: 74 }, 'KeyK': { code: 'KeyK', keyCode: 75 }, 'KeyL': { code: 'KeyL', keyCode: 76 }, 'Colon': { code: 'Colon', keyCode: 59 }, 'Quote': { code: 'Quote', keyCode: 222 }, 'Enter': { code: 'Enter', keyCode: 13 },
			'ShiftLeft': { code: 'ShiftLeft', keyCode: 16 }, 'KeyZ': { code: 'KeyZ', keyCode: 90 }, 'KeyX': { code: 'KeyX', keyCode: 88 }, 'KeyC': { code: 'KeyC', keyCode: 67 }, 'KeyV': { code: 'KeyV', keyCode: 86 }, 'KeyB': { code: 'KeyB', keyCode: 66 }, 'KeyN': { code: 'KeyN', keyCode: 78 }, 'KeyM': { code: 'KeyM', keyCode: 77 }, 'Comma': { code: 'Comma', keyCode: 188 }, 'Period': { code: 'Period', keyCode: 190 }, 'Slash': { code: 'Slash', keyCode: 191 }, 'ShiftRight': { code: 'ShiftRight', keyCode: 16 },
			'ControlLeft': { code: 'ControlLeft', keyCode: 17 }, 'AltLeft': { code: 'AltLeft', keyCode: 18 }, 'Space': { code: 'Space', keyCode: 32 }, 'AltRight': { code: 'AltRight', keyCode: 18 }, 'ControlRight': { code: 'ControlRight', keyCode: 17 }, 'ArrowLeft': { code: 'ArrowLeft', keyCode: 37 }, 'ArrowUp': { code: 'ArrowUp', keyCode: 38 }, 'ArrowDown': { code: 'ArrowDown', keyCode: 40 }, 'ArrowRight': { code: 'ArrowRight', keyCode: 39 }
		};

		let pressedKeys = {};
		const lockableKeys = new Set(['ShiftLeft','ShiftRight','AltLeft','AltRight','ControlLeft','ControlRight','CapsLock']);
		let lockedKeys = { ShiftLeft:false, ShiftRight:false, AltLeft:false, AltRight:false, ControlLeft:false, ControlRight:false, CapsLock:false };
		let holdTimers = {}; // key -> timeout id
		function sendKeyToEmulator(key, down) {
			const map = keyMap[key];
			if (!map) return;
			const canvas = document.getElementById('screen-canvas');
			if (!canvas) return;
			const event = new KeyboardEvent(down ? 'keydown' : 'keyup', {
				key: key === 'Space' ? ' ' : (key.startsWith('Key') ? key.slice(3) : key),
				code: map.code,
				keyCode: map.keyCode,
				which: map.keyCode,
				bubbles: true,
				cancelable: true,
				shiftKey: (pressedKeys['ShiftLeft'] || pressedKeys['ShiftRight'] || lockedKeys['ShiftLeft'] || lockedKeys['ShiftRight'] || false),
				ctrlKey: (pressedKeys['ControlLeft'] || pressedKeys['ControlRight'] || lockedKeys['ControlLeft'] || lockedKeys['ControlRight'] || false),
				altKey: (pressedKeys['AltLeft'] || pressedKeys['AltRight'] || lockedKeys['AltLeft'] || lockedKeys['AltRight'] || false),
				metaKey: false
			});
			canvas.dispatchEvent(event);
		}

		function updateModifierVisual(key, el){
			if (!el) return;
			if (key === 'CapsLock') {
				// For CapsLock, use only the LED, no blue highlight
				el.classList.remove('kb-locked');
				const led = el.querySelector('#caps-led');
				if (led) led.classList.toggle('on', !!lockedKeys[key]);
				return;
			}
			// For other modifiers, use the blue locked highlight
			el.classList.toggle('kb-locked', !!lockedKeys[key]);
		}

		function handleModifierMouseDown(el, key){
			// If already locked, unlock on click and send keyup
			if (lockedKeys[key]) {
				lockedKeys[key] = false;
				pressedKeys[key] = false;
				updateModifierVisual(key, el);
				if (key === 'CapsLock') {
					// Toggle off: send quick down+up
					sendKeyToEmulator(key, true);
					sendKeyToEmulator(key, false);
					// Update LED
					updateModifierVisual(key, el);
				} else {
					// send keyup to clear modifier in emulator
					sendKeyToEmulator(key, false);
				}
				// mark to suppress mouseup duplicate handling
				el.dataset.justUnlocked = '1';
				return;
			}
			if (key === 'CapsLock') {
				// Immediate toggle on press
				sendKeyToEmulator(key, true);
				sendKeyToEmulator(key, false);
				el.classList.add('kb-active');
				// start hold-to-lock visual (1s)
				clearTimeout(holdTimers[key]);
				holdTimers[key] = setTimeout(() => {
					lockedKeys[key] = true;
					updateModifierVisual(key, el);
				}, 1000);
				return;
			}
			pressedKeys[key] = true;
			el.classList.add('kb-active');
			sendKeyToEmulator(key, true);
			// start hold-to-lock timer (1s)
			clearTimeout(holdTimers[key]);
			holdTimers[key] = setTimeout(() => {
				lockedKeys[key] = true;
				updateModifierVisual(key, el);
				// keep pressed state, do not send keyup on mouseup
			}, 1000);
		}

		function handleModifierMouseUp(el, key){
			el.classList.remove('kb-active');
			clearTimeout(holdTimers[key]);
			if (el && el.dataset && el.dataset.justUnlocked === '1') {
				delete el.dataset.justUnlocked;
				if (key === 'CapsLock') updateModifierVisual(key, el);
				return;
			}
			if (key === 'CapsLock') {
				// For Caps, do not send any extra events on mouseup
				return;
			}
			if (lockedKeys[key]) {
				// remain pressed; don't send keyup
				pressedKeys[key] = true;
				return;
			}
			pressedKeys[key] = false;
			sendKeyToEmulator(key, false);
		}

		function setupPopupKeyboard() {
			const popup = document.getElementById('popup-keyboard');
			const closeBtn = document.getElementById('close-keyboard-btn');
			closeBtn.onclick = function() {
				popup.style.display = 'none';
				const kbItem = document.getElementById('mi-keyboard');
				if (kbItem) kbItem.textContent = 'Keyboard: Show';
			};
			popup.addEventListener('mousedown', function(e){
				if (e.target.classList.contains('kb-key')) {
					const key = e.target.getAttribute('data-key');
					if (lockableKeys.has(key)) {
						handleModifierMouseDown(e.target, key);
					} else {
						pressedKeys[key] = true;
						e.target.classList.add('kb-active');
						sendKeyToEmulator(key, true);
					}
					e.preventDefault();
				}
			});
			popup.addEventListener('mouseup', function(e){
				if (e.target.classList.contains('kb-key')) {
					const key = e.target.getAttribute('data-key');
					if (lockableKeys.has(key)) {
						handleModifierMouseUp(e.target, key);
					} else {
						pressedKeys[key] = false;
						e.target.classList.remove('kb-active');
						sendKeyToEmulator(key, false);
					}
					e.preventDefault();
				}
			});
			popup.addEventListener('touchstart', function(e){
				const t = e.target;
				if (t.classList.contains('kb-key')) {
					const key = t.getAttribute('data-key');
					if (lockableKeys.has(key)) {
						handleModifierMouseDown(t, key);
					} else {
						pressedKeys[key] = true;
						t.classList.add('kb-active');
						sendKeyToEmulator(key, true);
					}
					e.preventDefault();
				}
			}, { passive: false });
			popup.addEventListener('touchend', function(e){
				const t = e.target;
				if (t.classList.contains('kb-key')) {
					const key = t.getAttribute('data-key');
					if (lockableKeys.has(key)) {
						handleModifierMouseUp(t, key);
					} else {
						pressedKeys[key] = false;
						t.classList.remove('kb-active');
						sendKeyToEmulator(key, false);
					}
					e.preventDefault();
				}
			}, { passive: false });
			popup.addEventListener('click', function(e){ e.preventDefault(); });

			// Omni-directional drag support
			const dragHandle = document.getElementById('kb-drag');
			let dragging = false;
			let startX = 0, startY = 0; // Mouse start position
			let startLeft = 0, startTop = 0; // Keyboard element start position

			function getScale() {
				const s = document.getElementById('kbsize-slider');
				return (parseInt(s.value, 10) || 100) / 100;
			}

			function onDragStart(e) {
				e.preventDefault();
				e.stopPropagation();

				dragging = true;
				kbManuallyPositioned = true; // Mark that the user is in control of position

				const clientX = e.touches ? e.touches[0].clientX : e.clientX;
				const clientY = e.touches ? e.touches[0].clientY : e.clientY;

				const rect = popup.getBoundingClientRect();
				const parentRect = popup.parentElement.getBoundingClientRect();

				// Calculate the initial top/left based on the current rendered position
				startLeft = rect.left - parentRect.left;
				startTop = rect.top - parentRect.top;

				// Set the style to use explicit top/left for positioning.
				// This overrides the initial `bottom` and `left: 50%`.
				popup.style.left = startLeft + 'px';
				popup.style.top = startTop + 'px';
				popup.style.bottom = 'auto';
				popup.style.right = 'auto';

				// Remove the centering `translateX` from the transform, but keep the scale.
				// Set the origin to top-left so scaling doesn't shift the position.
				popup.style.transform = `scale(${getScale()})`;
				popup.style.transformOrigin = 'top left';

				// Store the starting mouse coordinates
				startX = clientX;
				startY = clientY;

				// Add listeners to the whole document to track movement anywhere on the page
				document.addEventListener('mousemove', onDragMove, { capture: true });
				document.addEventListener('mouseup', onDragEnd, { capture: true });
				document.addEventListener('touchmove', onDragMove, { passive: false, capture: true });
				document.addEventListener('touchend', onDragEnd, { capture: true });
			}

			function onDragMove(e) {
				if (!dragging) return;
				e.preventDefault();

				const clientX = e.touches ? e.touches[0].clientX : e.clientX;
				const clientY = e.touches ? e.touches[0].clientY : e.clientY;

				// Calculate the distance the mouse has moved
				const deltaX = clientX - startX;
				const deltaY = clientY - startY;

				// Calculate the new position of the keyboard
				let newLeft = startLeft + deltaX;
				let newTop = startTop + deltaY;

				// Constrain the keyboard within its parent container
				const parentRect = popup.parentElement.getBoundingClientRect();
				// Get current popup size, which is affected by CSS scale
				const popupWidth = popup.offsetWidth * getScale();
				const popupHeight = popup.offsetHeight * getScale();

				newLeft = Math.max(0, Math.min(newLeft, parentRect.width - popupWidth));
				newTop = Math.max(0, Math.min(newTop, parentRect.height - popupHeight));

				// Apply the new position
				popup.style.left = newLeft + 'px';
				popup.style.top = newTop + 'px';
			}

			function onDragEnd() {
				dragging = false;
				// Clean up the document-level listeners
				document.removeEventListener('mousemove', onDragMove, { capture: true });
				document.removeEventListener('mouseup', onDragEnd, { capture: true });
				document.removeEventListener('touchmove', onDragMove, { capture: true });
				document.removeEventListener('touchend', onDragEnd, { capture: true });
			}

			if (dragHandle) {
				dragHandle.addEventListener('mousedown', onDragStart);
				dragHandle.addEventListener('touchstart', onDragStart, { passive: false });
			}


			// Initialize visual state for modifiers if previously locked
			['ShiftLeft','ShiftRight','AltLeft','AltRight','ControlLeft','ControlRight','CapsLock'].forEach(k => {
				const el = popup.querySelector(`.kb-key[data-key="${k}"]`);
				if (el) {
					updateModifierVisual(k, el);
					if (lockedKeys[k]) el.classList.remove('kb-active');
				}
			});
		}
	</script>
</body>
</html>